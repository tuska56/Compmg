const NuncioEngine = {
    // Marcador de inicio de bloque en el fichero ,

    /**
     * DESENCRIPTAR / LEER
     * Convierte el ArrayBuffer del fichero en un objeto JSON con todos los datos.
     */
    decode: function(arrayBuffer) {
        const uint8 = new Uint8Array(arrayBuffer);
        const view = new DataView(arrayBuffer);
        const results = {
            metadata: { size: uint8.length, timestamp: new Date() },
            sources: []
        };

        // 1. Escaneo de estructura (Localizar etiquetas )
        let blocks = [];
        for (let i = 0; i < uint8.length - 15; i++) {
            let match = true;
            for (let j = 0; j < this.MARKER.length; j++) {
                if (uint8[i + j] !== this.MARKER[j]) { match = false; break; }
            }
            if (match) {
                let idStr = "";
                let k = i + 8;
                while (uint8[k] !== 93 && k < i + 15) { // 93 es "]"
                    idStr += String.fromCharCode(uint8[k]);
                    k++;
                }
                blocks.push({ id: parseInt(idStr), start: i, dataStart: k + 1 });
            }
        }

        // 2. Extracción de datos numéricos
        blocks.forEach((block, idx) => {
            const end = (blocks[idx + 1]) ? blocks[idx + 1].start : uint8.length;
            const sourceData = {
                id: block.id,
                points: []
            };

            // Si es un eje (ID 1 al 12), leemos paquetes de 48 bytes (6 doubles)
            if (block.id < 13) {
                const numPoints = Math.floor((end - block.dataStart) / 48);
                for (let p = 0; p < numPoints; p++) {
                    let offset = block.dataStart + (p * 48);
                    sourceData.points.push({
                        tx: view.getFloat64(offset, true),
                        ty: view.getFloat64(offset + 8, true),
                        tz: view.getFloat64(offset + 16, true),
                        rx: view.getFloat64(offset + 24, true),
                        ry: view.getFloat64(offset + 32, true),
                        rz: view.getFloat64(offset + 40, true)
                    });
                }
            } else {
                // Bloque 13 o superiores (Configuración/Metadatos)
                // Leemos los valores como una lista simple de parámetros
                sourceData.params = [];
                for (let offset = block.dataStart; offset + 8 <= end; offset += 8) {
                    sourceData.params.push(view.getFloat64(offset, true));
                }
            }
            results.sources.push(sourceData);
        });

        return results;
    },

    /**
     * ENCRIPTAR / GENERAR
     * Toma el buffer original y los nuevos datos para generar el fichero compatible.
     * Inyecta los datos en el molde original para garantizar compatibilidad.
     */
    encode: function(originalBuffer, updatedData) {
        // Creamos una copia del buffer para no destruir el original
        const newBuffer = new Uint8Array(originalBuffer);
        const view = new DataView(newBuffer.buffer);

        // Mapeamos los bloques del buffer para saber dónde escribir
        const blocks = this.getStructure(newBuffer);

        updatedData.sources.forEach(source => {
            const blockRef = blocks.find(b => b.id === source.id);
            if (!blockRef) return;

            if (source.points) {
                source.points.forEach((pt, pIdx) => {
                    let offset = blockRef.dataStart + (pIdx * 48);
                    // Inyección de los 6 parámetros por punto
                    if (offset + 48 <= newBuffer.length) {
                        view.setFloat64(offset, pt.tx, true);
                        view.setFloat64(offset + 8, pt.ty, true);
                        view.setFloat64(offset + 16, pt.tz, true);
                        view.setFloat64(offset + 24, pt.rx, true);
                        view.setFloat64(offset + 32, pt.ry, true);
                        view.setFloat64(offset + 40, pt.rz, true);
                    }
                });
            } else if (source.params) {
                source.params.forEach((val, vIdx) => {
                    let offset = blockRef.dataStart + (vIdx * 8);
                    if (offset + 8 <= newBuffer.length) {
                        view.setFloat64(offset, val, true);
                    }
                });
            }
        });

        return newBuffer;
    },

    /**
     * Función auxiliar para mapear la estructura sin extraer datos
     */
    getStructure: function(uint8) {
        let blocks = [];
        for (let i = 0; i < uint8.length - 15; i++) {
            let match = true;
            for (let j = 0; j < this.MARKER.length; j++) {
                if (uint8[i + j] !== this.MARKER[j]) { match = false; break; }
            }
            if (match) {
                let idStr = "";
                let k = i + 8;
                while (uint8[k] !== 93 && k < i + 15) {
                    idStr += String.fromCharCode(uint8[k]);
                    k++;
                }
                blocks.push({ id: parseInt(idStr), dataStart: k + 1 });
            }
        }
        return blocks;
    }
};
